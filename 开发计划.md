# 三层嵌套 Master-Detail 开发计划

## 目标

扩展现有 `MasterDetailPage.vue`，支持 AG Grid 原生三层嵌套展示（主表 → 汇总行 → 明细 Grid），通过元数据配置切换展示模式，支持变体列。

---

## 阶段一：元数据配置解析 ✅

**改动文件**：`cost-web/src/logic/calc-engine/parser.ts`

**改动内容**：
- [x] 新增 `NestedConfig` 接口（enabled, summaryColumns, summaryAggregates, groupLabelField）
- [x] 新增 `SummaryAggConfig` 接口（sourceField, targetField, algorithm）
- [x] 新增 `SummaryColumnConfig` 接口（field, headerName, width）
- [x] `TabConfig` 增加 `variantKey` 字段
- [x] `ParsedPageConfig` 增加 `nestedConfig` 字段
- [x] `parsePageComponents()` 解析 nestedConfig

**目的**：通过元数据驱动三层嵌套的展示和计算

---

## 阶段二：Store 扩展 - 汇总行 computed ✅

**改动文件**：`cost-web/src/store/modules/master-detail/index.ts`

**改动内容**：
- [x] 新增 `summaryRows` computed，按 Tab 分组
- [x] 汇总行包含：_groupKey、_groupValue、groupLabel、_detailRows、_variantKey、聚合字段

**目的**：为三层嵌套的第二层提供数据源

---

## 阶段三：页面组件支持嵌套模式 ✅

**改动文件**：`cost-web/src/components/meta-v4/MasterDetailPage.vue`

**改动内容**：
- [x] 新增 `isNestedMode` computed 检测嵌套模式
- [x] 新增 `masterDetailParams` computed 配置主表 Master-Detail
- [x] 新增 `getSummaryDetailParams()` 配置汇总行展开到明细 Grid
- [x] 新增 `onMasterRowExpanded()` 处理主表展开事件
- [x] 模板增加三层嵌套模式分支

**目的**：同一组件支持分屏和嵌套两种模式

---

## 阶段四：变体列支持

**改动文件**：
- [ ] 后端：`T_COST_COLUMN_METADATA` 增加 `VARIANT_KEY` 字段（或在 RULES_CONFIG 中配置）
- [x] 前端：`useMetaColumns.ts` 增加 `filterColumnsByVariant()` 函数
- [x] `getSummaryDetailParams()` 改为函数形式，根据 `_variantKey` 动态返回列定义

**目的**：不同分组显示不同列（原辅料 vs 包材）

**说明**：变体列配置方式有两种选择：
1. 在 `T_COST_COLUMN_METADATA` 增加 `VARIANT_KEY` 字段
2. 在现有 `RULES_CONFIG` JSON 中增加 `variantKey` 属性

建议使用方案 2，无需改数据库结构，配置示例：
```json
{"variantKey": "原辅料", "calculate": {...}}
```

---

## 阶段五：编辑与计算 ✅

**改动内容**：
- [x] 明细 Grid 添加 `onCellValueChanged` 事件，调用 `store.updateField()`
- [x] 复用现有计算链：行级计算 → 聚合计算 → 主表更新
- [x] `summaryRows` 是 computed，自动响应 `detailRowsByTab` 变化

**目的**：保持计算逻辑一致

**说明**：
- 明细行编辑 → `updateField()` → 触发行级计算 → 触发聚合计算
- `summaryRows` computed 会自动重算聚合值
- 主表聚合由现有 `triggerAggCalc()` 处理

---

## 阶段六：保存与收尾 ✅

**改动内容**：
- [x] 保存逻辑复用 `buildSaveParams()`，数据结构不变
- [x] 删除测试组件 `MasterDetailNested.vue`
- [x] 清理 `dynamic/index.vue` 中的 `?nested=1` 测试代码

**目的**：功能完整可用

---

## 当前进度

**全部阶段完成！**

三层嵌套功能已整合到 `MasterDetailPage.vue`，通过元数据配置 `nestedConfig.enabled: true` 启用。


---

## 架构重构：全面拥抱 AG Grid 原生能力

### 重构目标

**核心思路**：把计算、变更追踪、数据刷新全部交给 AG Grid，Store 只做数据缓存和后端交互。

**预期效果**：
- Store：600+ 行 → 100 行
- 组件：1100+ 行 → 400 行
- 删除 calc-engine 大部分代码

---

### 一、AG Grid 原生能力梳理

| 功能 | AG Grid API | 替代现有代码 |
|-----|------------|-------------|
| 原始值记录 | `undoRedoCellEditing: true` | `_originalValues` |
| 撤销/重做 | `api.undoCellEditing()` / `api.redoCellEditing()` | 无 |
| 变更检测 | `onCellValueChanged` 的 `oldValue`/`newValue` | `_changeType` |
| 单元格刷新 | `api.refreshCells()` | `updateVersion` + watch |
| 跨 Grid 取数据 | `api.getDetailGridInfo()` | Store computed |
| 跨 Grid 改数据 | `detailApi.forEachNode()` + `setDataValue()` | Store 计算链 |
| 行内聚合 | `aggFunc: 'sum'` + Row Grouping | `summaryRows` computed |
| 脏数据标记 | `onCellValueChanged` 里标记 `_isDirty` | Store `isRowDirty()` |

---

### 二、新架构设计

#### 2.1 Store 精简（只保留缓存和后端交互）

```typescript
// 新 Store 结构（约 100 行）
const store = {
  // === 状态 ===
  masterRows: [],                    // 主表数据
  detailCache: Map<masterId, rows[]>, // 从表缓存（主表切换时不丢失）
  currentMasterId: null,
  
  // === 后端交互 ===
  async loadMaster(),
  async loadDetail(masterId),
  async save(dirtyData),
  
  // === 缓存管理 ===
  cacheDetail(masterId, rows),
  getDetailFromCache(masterId),
  clearCache(),
}
```

**删除的内容**：
- `compiledCalcRules`、`compiledAggRules`、`compiledMasterCalcRules`
- `triggerDetailCalc()`、`triggerAggCalc()`、`runXxxCalc()` 系列
- `updateField()`、`updateFields()`、`updateFieldSilent()`
- `summaryRows` computed
- `detailRowsByTab` computed
- `markChange()`、`isValueEqual()`
- `_changeType`、`_originalValues` 相关逻辑

#### 2.2 计算逻辑移到 Grid 事件

```typescript
// 从表编辑 → 行级计算 + 聚合到主表
function onDetailCellValueChanged(event, masterId) {
  const { colDef, data, newValue, api: detailApi } = event;
  const field = colDef.field;
  
  // 1. 行级计算（同行其他字段）
  const calcRules = getCalcRulesForField(field);
  for (const rule of calcRules) {
    const result = rule.calculate(data);
    if (result !== data[rule.targetField]) {
      event.node.setDataValue(rule.targetField, result);
    }
  }
  
  // 2. 聚合到主表
  const aggRules = getAggRulesForMaster();
  const masterNode = masterGridApi.getRowNode(masterId);
  
  for (const rule of aggRules) {
    let total = 0;
    detailApi.forEachNode(node => {
      if (!node.data._isDeleted) {
        total += node.data[rule.sourceField] || 0;
      }
    });
    masterNode.setDataValue(rule.targetField, total);
  }
  
  // 3. 标记脏数据
  data._isDirty = true;
}

// 主表编辑 → 广播到从表
function onMasterCellValueChanged(event) {
  const { colDef, data, newValue } = event;
  const field = colDef.field;
  
  // 检查是否是广播字段
  if (!broadcastFields.includes(field)) return;
  
  // 获取从表 Grid
  const detailInfo = masterGridApi.getDetailGridInfo(`detail_${data.id}`);
  if (!detailInfo?.api) return;
  
  // 广播到从表每一行，触发重算
  detailInfo.api.forEachNode(node => {
    // 从表行级计算（使用主表新值）
    const calcRules = getCalcRulesForBroadcast(field);
    for (const rule of calcRules) {
      const context = { ...data, [field]: newValue };
      const result = rule.calculate(node.data, context);
      node.setDataValue(rule.targetField, result);
    }
  });
  
  // 标记脏数据
  data._isDirty = true;
}
```

#### 2.3 变更追踪用 AG Grid 原生

```typescript
// Grid 配置
{
  undoRedoCellEditing: true,
  undoRedoCellEditingLimit: 20,
  
  onCellValueChanged: (event) => {
    // 标记脏数据
    event.data._isDirty = true;
    event.data._dirtyFields = event.data._dirtyFields || {};
    event.data._dirtyFields[event.colDef.field] = {
      oldValue: event.oldValue,
      newValue: event.newValue
    };
  }
}

// 保存时收集脏数据
function collectDirtyData() {
  const dirtyMaster = [];
  const dirtyDetail = [];
  
  masterGridApi.forEachNode(node => {
    if (node.data._isDirty || node.data._isNew || node.data._isDeleted) {
      dirtyMaster.push(node.data);
    }
  });
  
  // 遍历所有展开的从表
  masterGridApi.forEachNode(masterNode => {
    const detailInfo = masterGridApi.getDetailGridInfo(`detail_${masterNode.data.id}`);
    if (detailInfo?.api) {
      detailInfo.api.forEachNode(detailNode => {
        if (detailNode.data._isDirty || detailNode.data._isNew || detailNode.data._isDeleted) {
          dirtyDetail.push(detailNode.data);
        }
      });
    }
  });
  
  return { dirtyMaster, dirtyDetail };
}
```

#### 2.4 三层嵌套简化

```typescript
// 主表配置
{
  masterDetail: true,
  detailCellRendererParams: (params) => {
    return {
      detailGridOptions: {
        // 第二层：汇总行（启用 Row Grouping）
        rowGroupPanelShow: 'never',
        groupDefaultExpanded: 0,
        autoGroupColumnDef: { headerName: '分类' },
        
        // 汇总行也支持展开
        masterDetail: true,
        detailCellRendererParams: (summaryParams) => {
          // 根据分组类型返回不同列定义
          const groupKey = summaryParams.data._groupKey;
          return {
            detailGridOptions: {
              columnDefs: getColumnsForGroup(groupKey),
              onCellValueChanged: (e) => onDetailCellValueChanged(e, params.data.id)
            },
            getDetailRowData: (p) => {
              p.successCallback(summaryParams.data._detailRows);
            }
          };
        }
      },
      getDetailRowData: (p) => {
        // 加载汇总行数据
        const summaryRows = buildSummaryRows(params.data.id);
        p.successCallback(summaryRows);
      }
    };
  }
}
```

---

### 三、改造步骤

#### 阶段 1：启用 AG Grid 原生变更追踪

1. 添加 `undoRedoCellEditing: true` 配置
2. 在 `onCellValueChanged` 里标记 `_isDirty`
3. 删除 Store 里的 `_originalValues`、`_changeType` 相关代码
4. 测试撤销/重做功能

#### 阶段 2：计算逻辑迁移到 Grid 事件

1. 在 `onDetailCellValueChanged` 里实现行级计算
2. 在 `onDetailCellValueChanged` 里实现聚合到主表
3. 在 `onMasterCellValueChanged` 里实现广播到从表
4. 删除 Store 里的 `triggerXxxCalc()`、`runXxxCalc()` 系列函数
5. 删除 `compiledCalcRules`、`compiledAggRules` 等

#### 阶段 3：Store 精简

1. 删除计算相关代码
2. 保留数据缓存和后端交互
3. 简化 `save()` 逻辑，用 `collectDirtyData()` 收集脏数据

#### 阶段 4：组件精简

1. 删除 `updateVersion` + watch 刷新机制
2. 删除 `summaryRows` computed 相关代码
3. 简化三层嵌套配置

---

### 四、风险评估

| 风险 | 影响 | 应对 |
|-----|-----|-----|
| AG Grid undo/redo 不支持跨 Grid | 从表撤销不影响主表聚合值 | 聚合值单独处理，或禁用从表 undo |
| 性能问题（大量行遍历） | 聚合计算变慢 | 用 `forEachNode` 的 `includeFooterNodes: false` 优化 |
| 三层嵌套 Detail Grid 获取复杂 | 代码可读性 | 封装 `getNestedDetailApi(masterId, groupKey)` 工具函数 |

---

### 五、预期收益

| 指标 | 改造前 | 改造后 |
|-----|-------|-------|
| Store 代码量 | 600+ 行 | ~100 行 |
| 组件代码量 | 1100+ 行 | ~400 行 |
| calc-engine | 复杂 | 可删除大部分 |
| 调试难度 | 高（数据在 Store 和 Grid 之间跳） | 低（数据只在 Grid 里） |
| 学习成本 | 高（自定义计算链） | 低（标准 AG Grid API） |
