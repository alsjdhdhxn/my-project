# 3.1 表和列元数据配置说明

## 核心机制

通过 `T_COST_TABLE_METADATA` 和 `T_COST_COLUMN_METADATA` 配置表结构，实现：
- **查询走视图**（QUERY_VIEW）：可包含 JOIN、计算列
- **保存走表**（TARGET_TABLE）：直接操作物理表

## 表元数据字段

| 字段 | 说明 |
|------|------|
| TABLE_CODE | 表编码（前端/接口使用） |
| TABLE_NAME | 表名称（展示用） |
| QUERY_VIEW | 查询视图（SELECT 来源） |
| TARGET_TABLE | 保存目标表（INSERT/UPDATE/DELETE） |
| SEQUENCE_NAME | 序列名（新增主键） |
| PK_COLUMN | 主键列（默认 ID） |
| PARENT_TABLE_CODE | 父表编码（从表必填） |
| PARENT_FK_COLUMN | 从表外键列名（从表必填） |

## 列元数据字段

| 字段 | 说明 |
|------|------|
| FIELD_NAME | 前端字段名（camelCase） |
| COLUMN_NAME | 数据库列名（大写下划线） |
| HEADER_TEXT | 表头显示名称 |
| DATA_TYPE | 数据类型：text / number / date / datetime |
| DISPLAY_ORDER | 显示顺序 |
| IS_VIRTUAL | 1=虚拟列（只计算不落库） |
| DICT_TYPE | 字典类型（下拉使用） |

## 完整配置案例

以"产品信息"表为例，包含主表配置和列配置：

```sql
-- 1. 表元数据
INSERT INTO T_COST_TABLE_METADATA (
  ID, TABLE_CODE, TABLE_NAME, QUERY_VIEW, TARGET_TABLE, 
  SEQUENCE_NAME, PK_COLUMN, CREATE_BY
) VALUES (
  SEQ_COST_TABLE_METADATA.NEXTVAL,
  'CostGoods',
  '产品信息',
  'V_COST_GOODS',      -- 查询视图
  'T_COST_GOODS',      -- 保存目标表
  'SEQ_COST_GOODS',
  'GOODSID',
  'system'
);

-- 2. 列元数据（假设表ID为1）
INSERT ALL
  INTO T_COST_COLUMN_METADATA (ID, TABLE_METADATA_ID, FIELD_NAME, COLUMN_NAME, HEADER_TEXT, DATA_TYPE, DISPLAY_ORDER, CREATE_BY)
  VALUES (SEQ_COST_COLUMN_METADATA.NEXTVAL, 1, 'goodsid', 'GOODSID', '产品ID', 'number', 1, 'system')
  INTO T_COST_COLUMN_METADATA (ID, TABLE_METADATA_ID, FIELD_NAME, COLUMN_NAME, HEADER_TEXT, DATA_TYPE, DISPLAY_ORDER, CREATE_BY)
  VALUES (SEQ_COST_COLUMN_METADATA.NEXTVAL, 1, 'goodsname', 'GOODSNAME', '产品名称', 'text', 2, 'system')
  INTO T_COST_COLUMN_METADATA (ID, TABLE_METADATA_ID, FIELD_NAME, COLUMN_NAME, HEADER_TEXT, DATA_TYPE, DISPLAY_ORDER, CREATE_BY)
  VALUES (SEQ_COST_COLUMN_METADATA.NEXTVAL, 1, 'price', 'PRICE', '单价', 'number', 3, 'system')
  INTO T_COST_COLUMN_METADATA (ID, TABLE_METADATA_ID, FIELD_NAME, COLUMN_NAME, HEADER_TEXT, DATA_TYPE, DISPLAY_ORDER, CREATE_BY)
  VALUES (SEQ_COST_COLUMN_METADATA.NEXTVAL, 1, 'useflag', 'USEFLAG', '类型', 'text', 4, 'system')
SELECT 1 FROM DUAL;
```

## 主从表配置案例

```sql
-- 主表
INSERT INTO T_COST_TABLE_METADATA (
  ID, TABLE_CODE, TABLE_NAME, QUERY_VIEW, TARGET_TABLE, 
  SEQUENCE_NAME, PK_COLUMN, CREATE_BY
) VALUES (
  SEQ_COST_TABLE_METADATA.NEXTVAL,
  'CostPinggu', '成本评估',
  'V_COST_PINGGU', 'T_COST_PINGGU',
  'SEQ_COST_PINGGU', 'DOCID', 'system'
);

-- 从表（指定父表关系）
INSERT INTO T_COST_TABLE_METADATA (
  ID, TABLE_CODE, TABLE_NAME, QUERY_VIEW, TARGET_TABLE, 
  SEQUENCE_NAME, PK_COLUMN, PARENT_TABLE_CODE, PARENT_FK_COLUMN, CREATE_BY
) VALUES (
  SEQ_COST_TABLE_METADATA.NEXTVAL,
  'CostMaterial', '原料辅料',
  'V_COST_PINGGU_MATERIAL', 'T_COST_PINGGU_DTL',
  'SEQ_COST_PINGGU_DTL', 'ID',
  'CostPinggu', 'MASTER_ID', 'system'
);
```

## 注意事项

- QUERY_VIEW 必须包含主键列和所有可编辑字段
- 从表必须配置 PARENT_TABLE_CODE 和 PARENT_FK_COLUMN
- FIELD_NAME 使用 camelCase，COLUMN_NAME 使用大写下划线
- 虚拟列（IS_VIRTUAL=1）不会参与保存，但可参与计算与展示
