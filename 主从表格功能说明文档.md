# 主从表格功能说明文档

> 本文档详细说明 cost-web 项目中主从表格（MasterDetailPage）的完整功能实现，供技术评审和改造方案评估使用。

---

## 一、整体架构

### 1.1 核心组件清单

| 组件 | 路径 | 职责 |
|------|------|------|
| MasterDetailPage.vue | components/meta-v4/ | 主从表格页面组件，负责布局、事件处理、数据加载 |
| MetaTabs.vue | components/meta-v4/ | 从表 Tab 容器，支持多 Tab 并列显示 |
| LookupDialog.vue | components/meta-v4/ | 弹窗选择器，支持数据选择和字段回填 |
| useMasterDetailStore | store/modules/master-detail/ | Pinia Store，数据管理、缓存、计算触发 |
| useGridAdapter | composables/ | AG Grid 适配器，Store ↔ Grid 双向同步 |
| useMetaColumns | composables/ | 元数据转 AG Grid ColDef，样式规则提取 |
| calc-engine | logic/calc-engine/ | 计算引擎（calculator/parser/validator/builder） |

### 1.2 数据流向图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           元数据层（数据库）                              │
│  T_COST_PAGE_COMPONENT → 页面结构、计算规则、聚合规则、右键菜单配置        │
│  T_COST_TABLE_METADATA → 表配置、验证规则、执行器规则                     │
│  T_COST_COLUMN_METADATA → 列定义、行级公式、校验规则、样式规则、Lookup配置 │
└─────────────────────────────────────────────────────────────────────────┘
                                    ↓ API 请求
┌─────────────────────────────────────────────────────────────────────────┐
│                           前端 Store 层                                  │
│  masterRows[]              # 主表数据（含 _details 嵌套从表）             │
│  compiledCalcRules[]       # 编译后的从表计算规则                         │
│  compiledAggRules[]        # 编译后的聚合规则                             │
│  compiledMasterCalcRules[] # 编译后的主表计算规则                         │
│  lruOrder[]                # LRU 缓存顺序                                │
└─────────────────────────────────────────────────────────────────────────┘
                                    ↓ 响应式绑定
┌─────────────────────────────────────────────────────────────────────────┐
│                           视图层                                         │
│  AG Grid (主表)  ←→  GridAdapter  ←→  Store.masterRows                  │
│  AG Grid (从表)  ←→  MetaTabs     ←→  Store.detailRowsByTab             │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 二、数据结构设计

### 2.1 主表行结构（MasterRowData）

```typescript
interface MasterRowData {
  id: number;                    // 主键（新增行为负数临时ID）
  [field: string]: any;          // 业务字段
  
  // 内部状态字段（以 _ 开头，不参与保存）
  _isNew: boolean;               // 是否新增行
  _isDeleted: boolean;           // 是否已删除（软删除标记）
  _changeType: Record<string, 'user' | 'cascade'>;  // 字段变更类型
  _originalValues: Record<string, any>;             // 原始值快照
  _details: DetailContainer | null;                 // 从表数据容器
}
```

### 2.2 从表数据容器（DetailContainer）

```typescript
interface DetailContainer {
  loaded: boolean;    // 是否已加载
  rows: RowData[];    // 从表行数组
}
```

**设计要点：**
- 从表数据挂在主表行的 `_details` 属性下，形成嵌套结构
- `loaded` 标记用于懒加载判断，避免重复请求
- 切换主表行时，从表数据保留在原主表行上，不会丢失

### 2.3 变更追踪机制

| 字段 | 类型 | 说明 |
|------|------|------|
| `_changeType` | `Record<string, 'user' \| 'cascade'>` | 记录每个字段的变更类型 |
| `_originalValues` | `Record<string, any>` | 加载时的原始值快照 |

**变更判断逻辑（builder.ts）：**
```typescript
function markChange(row: RowData, field: string, type: 'user' | 'cascade') {
  const currentValue = row[field];
  const originalValue = row._originalValues?.[field];

  if (isValueEqual(currentValue, originalValue)) {
    delete row._changeType[field];  // 恢复原值则清除变更标记
  } else {
    row._changeType[field] = type;
  }
}
```

### 2.4 临时 ID 生成（builder.ts）

```typescript
let tempIdCounter = 0;
export function generateTempId(): number {
  return -(Date.now() * 1000 + tempIdCounter++);
}
```

**设计要点：** 使用负数避免与数据库 ID 冲突，保存时后端会分配真实 ID。

---

## 三、数据加载机制

### 3.1 页面初始化流程（MasterDetailPage.vue）

```
onMounted()
  ├── loadMetadata()
  │     ├── fetchPageComponents(pageCode)        # 获取页面组件配置
  │     ├── parsePageComponents()                # 解析组件树，提取计算规则
  │     ├── 加载右键菜单配置（CONTEXT_MENU 组件）
  │     ├── loadTableMeta(masterTableCode, pageCode)  # 加载主表元数据（含权限合并）
  │     ├── loadTableMeta(detailTableCode, pageCode)  # 加载从表元数据（含权限合并）
  │     └── store.init()                         # 初始化 Store，编译计算规则
  │
  └── loadMasterData()
        ├── searchDynamicData(masterTableCode, { pageCode })  # 查询主表（带数据权限）
        ├── store.loadMaster(data)               # 加载到 Store
        │     └── 每行初始化 _details = null     # 从表数据待加载
        └── 自动选中第一行 → onMasterSelectionChanged()
              └── loadDetailData(masterId)       # 加载从表数据
```

### 3.2 从表懒加载机制（store/index.ts）

**触发时机：** 选中主表行时

```typescript
function selectMaster(id: number): boolean {
  if (currentMasterId.value === id) return false;  // 已选中同一行
  currentMasterId.value = id;

  const master = masterRows.value.find(r => r.id === id);
  if (!master) return false;

  // 新增行不需要加载（从表为空）
  if (master._isNew) {
    if (!master._details) {
      master._details = { loaded: true, rows: [] };
    }
    return false;
  }

  // 已加载过，更新 LRU 顺序
  if (master._details?.loaded) {
    updateLru(id);
    triggerReactiveUpdate();  // 通知 UI 刷新
    return false;             // 不需要重新加载
  }

  // 未加载，需要请求后端
  checkLruEviction();  // 检查是否需要清理缓存
  return true;         // 返回 true 表示需要加载
}
```

### 3.3 加载数据时不触发计算

```typescript
function loadDetail(data: Record<string, any>[]) {
  const master = currentMaster.value;
  if (!master) return;

  master._details = {
    loaded: true,
    rows: data.map(row => initRowData(row, false))  // isNew = false
  };

  // 更新 LRU
  if (master.id != null) {
    updateLru(master.id);
  }

  // 只触发 UI 刷新，不触发计算
  triggerReactiveUpdate();
  // 注意：这里没有调用 triggerDetailCalc() 或 triggerAggCalc()
}
```

**为什么加载时不计算？**
1. 后端返回的数据已经是计算好的结果
2. 避免加载时的性能开销
3. 保持数据一致性（后端计算 vs 前端计算）

---

## 四、计算引擎实现

### 4.1 计算规则来源

| 来源 | 配置位置 | 规则类型 | 说明 |
|------|----------|----------|------|
| 列元数据 | `COLUMN_METADATA.RULES_CONFIG.calculate` | 从表行级计算 | 单公式或多公式模式 |
| 页面组件 | `PAGE_COMPONENT.COMPONENT_CONFIG.calcRules` | 从表行级计算 | 补充规则 |
| 页面组件 | `PAGE_COMPONENT.COMPONENT_CONFIG.aggregates` | 聚合计算 | SUM/AVG/COUNT 等 |
| 页面组件 | `PAGE_COMPONENT.COMPONENT_CONFIG.masterCalcRules` | 主表计算 | 依赖聚合结果 |
| 页面组件 | `PAGE_COMPONENT.COMPONENT_CONFIG.postProcess` | 聚合后处理 | JS 表达式修正结果 |

### 4.2 计算规则类型定义（calculator.ts）

```typescript
/** 行级计算规则 */
interface CalcRule {
  field: string;           // 目标字段
  expression: string;      // 计算表达式（单公式模式）
  triggerFields: string[]; // 触发字段
  condition?: string;      // JS 语法条件，如 "useFlag !== '包材'"
  order?: number;          // 执行顺序
  // 多公式支持
  formulaField?: string;   // 指定用哪个字段的值来选公式
  formulas?: Record<string, FormulaDefinition>; // 公式映射表
}

/** 聚合规则 */
interface AggRule {
  sourceField?: string;    // 源字段
  targetField: string;     // 目标字段（主表）
  algorithm?: 'SUM' | 'AVG' | 'COUNT' | 'MAX' | 'MIN';
  filter?: string;         // JS 语法过滤，如 "useFlag === '原料'"
  expression?: string;     // 表达式计算，如 "totalYl + totalFl"
}
```

### 4.3 计算触发时机

| 场景 | 触发的计算 | 说明 |
|------|------------|------|
| 加载数据 | 无 | 数据已是计算结果 |
| 用户编辑从表字段 | 行级计算 → 聚合计算 | 只计算受影响的规则 |
| 用户编辑主表广播字段 | 从表全量重算 → 聚合计算 | 广播字段影响所有从表行 |
| Lookup 回填 | 行级计算 → 聚合计算 | 批量更新多个字段 |

### 4.4 字段更新流程（store/index.ts）

```typescript
function updateField(rowId, field, value, changeType = 'user', isMaster = false) {
  const row = isMaster
    ? masterRows.value.find(r => r.id === rowId)
    : detailRows.value.find(r => r.id === rowId);
  if (!row) return;

  // 1. 更新字段值
  row[field] = value;
  markChange(row, field, changeType);

  // 2. 触发响应式更新（通知 Grid 刷新）
  triggerReactiveUpdate();

  // 3. 主表广播字段变化 → 触发从表重算（全量）
  if (isMaster && config.value?.broadcast?.includes(field)) {
    triggerDetailCalc();
  }

  // 4. 从表用户修改 → 只计算受影响的规则
  if (!isMaster && changeType === 'user') {
    triggerDetailCalcForField(rowId, field);
    triggerAggCalc();
  }
}
```

### 4.5 增量计算优化（calculator.ts）

**只计算受影响的规则：**

```typescript
function getAffectedRules(field: string, rules: CompiledCalcRule[]): CompiledCalcRule[] {
  const affected = new Set<string>();
  const queue = [field];

  while (queue.length > 0) {
    const current = queue.shift()!;

    for (const rule of rules) {
      let isDep = false;

      // 检查 triggerFields
      if (rule.triggerFields.includes(current)) isDep = true;
      
      // 多公式模式：检查所有公式的 triggerFields
      if (rule.formulas) {
        for (const formula of Object.values(rule.formulas)) {
          if (formula.triggerFields.includes(current)) isDep = true;
        }
      }
      
      // 检查 formulaField 本身是否变化
      if (rule.formulaField === current) isDep = true;

      if (isDep && !affected.has(rule.field)) {
        affected.add(rule.field);
        queue.push(rule.field);  // 级联依赖
      }
    }
  }

  return rules.filter(r => affected.has(r.field));
}
```

### 4.6 级联计算支持

**最多 3 轮迭代，防止死循环：**

```typescript
const MAX_CALC_ROUNDS = 3;

for (let round = 0; round < MAX_CALC_ROUNDS; round++) {
  let hasChange = false;

  for (const row of rows) {
    const results = calcRowFields(row, context, rules);

    for (const [field, value] of Object.entries(results)) {
      if (!isValueEqual(row[field], value)) {
        row[field] = value;
        markChange(row, field, 'cascade');
        hasChange = true;
      }
    }
  }

  if (!hasChange) break;  // 无变化则提前退出
}
```

### 4.7 多公式模式（calculator.ts）

根据某个字段的值选择不同的计算公式：

```typescript
// 多公式模式：根据 formulaField 的值选择公式
if (rule.formulaField && rule.compiledFormulas) {
  const formulaKey = String(row[rule.formulaField] ?? '');
  const compiledFormula = rule.compiledFormulas[formulaKey];
  
  if (compiledFormula) {
    value = compiledFormula.evaluate(scope);
  } else {
    // 没有匹配的公式，保持原值不变
    continue;
  }
}
```

**配置示例：**
```json
{
  "calculate": {
    "formulaField": "dtlUseflag",
    "formulas": {
      "原料": { "expression": "batchQty * price", "triggerFields": ["batchQty", "price"] },
      "包材": { "expression": "batchQty * price * 1.1", "triggerFields": ["batchQty", "price"] }
    }
  }
}
```

### 4.8 聚合计算流程（calculator.ts）

```typescript
function calcAggregates(rows, rules, currentMaster, precision, postProcess) {
  const results: Record<string, number> = {};

  // 第一轮：执行 SUM/AVG/COUNT 等聚合
  for (const rule of rules) {
    if (rule.algorithm && rule.sourceField) {
      const filteredRows = rule.filter ? filterRows(rows, rule.filter) : rows;
      results[rule.targetField] = aggregate(filteredRows, rule.sourceField, rule.algorithm);
    }
  }

  // 第二轮：执行表达式计算（依赖第一轮结果）
  for (const rule of rules) {
    if (rule.compiledExpr && !rule.algorithm) {
      const context = { ...currentMaster, ...results };
      results[rule.targetField] = rule.compiledExpr.evaluate(context);
    }
  }

  // 第三轮：执行后处理（可修正聚合结果）
  if (postProcess) {
    const fn = new Function(...fields, `${postProcess}; return { ${fields.join(', ')} };`);
    const processed = fn(...Object.values(results));
    // 更新结果
  }

  return results;
}
```

**聚合配置示例：**
```json
{
  "aggregates": [
    { "sourceField": "costBatch", "targetField": "totalYl", "algorithm": "SUM", "filter": "dtlUseflag === '原料'" },
    { "sourceField": "costBatch", "targetField": "totalFl", "algorithm": "SUM", "filter": "dtlUseflag === '辅料'" },
    { "targetField": "totalMaterial", "expression": "totalYl + totalFl" }
  ],
  "postProcess": "if (totalYl > 0) { totalYl = totalYl / 1.13; }"
}
```

---

## 五、数据缓存与切换

### 5.1 LRU 缓存机制

**目的：** 限制内存占用，避免加载过多从表数据

**配置：**
```typescript
const MAX_CACHE_SIZE = 50;  // 最多缓存 50 个主表的从表数据
```

**LRU 顺序维护：**
```typescript
const lruOrder = ref<number[]>([]);  // masterId 列表，最近访问的在末尾

function updateLru(masterId: number) {
  const idx = lruOrder.value.indexOf(masterId);
  if (idx > -1) lruOrder.value.splice(idx, 1);  // 移除旧位置
  lruOrder.value.push(masterId);                 // 添加到末尾
}
```

**缓存清理：**
```typescript
function checkLruEviction(): boolean {
  if (loadedDetailCount.value < MAX_CACHE_SIZE) return true;

  // 找最久未访问的、无修改的主表
  for (const masterId of lruOrder.value) {
    const master = masterRows.value.find(r => r.id === masterId);
    if (master && master._details?.loaded && !isMasterDirty(master)) {
      master._details = null;  // 清除从表数据
      lruOrder.value.splice(lruOrder.value.indexOf(masterId), 1);
      return true;
    }
  }

  // 全都有修改，无法清理
  console.warn('[Store] 缓存已满且全部有修改，请先保存数据');
  return false;
}
```

**关键设计：有修改的数据不会被清理**

### 5.2 切换主表行时的数据保留

**场景：**
1. 用户选中主表行 A，编辑从表数据
2. 用户切换到主表行 B
3. 用户切换回主表行 A

**数据流：**
```
选中 A → A._details.rows 加载数据
编辑 A 的从表 → A._details.rows 更新，_changeType 记录变更
切换到 B → A._details 保留不变，B._details 加载数据
切换回 A → A._details 已存在且 loaded=true，直接使用缓存
```

---

## 六、数据保存机制

### 6.1 保存参数构建（builder.ts）

```typescript
function buildSaveParams(pageCode, masterRows, masterTableCode, detailTableCode, parentFkColumn) {
  const result: SaveParams[] = [];

  for (const masterRow of masterRows) {
    const detailRows = masterRow._details?.rows || [];
    const masterChanged = isRowChanged(masterRow);
    const detailsChanged = detailRows.some(isRowChanged);

    // 主表或从表有变更才需要保存
    if (!masterChanged && !detailsChanged) continue;

    result.push({
      pageCode,
      master: buildRecordItem(masterRow, masterTableCode),
      details: {
        [detailTableCode]: detailRows
          .filter(isRowChanged)
          .map(row => buildRecordItem(row, detailTableCode, masterRow.id, parentFkColumn))
      }
    });
  }

  return result;
}
```

### 6.2 单条记录参数（builder.ts）

```typescript
function buildRecordItem(row, tableCode, parentId?, parentFkColumn?) {
  // 确定状态
  let status: 'added' | 'modified' | 'deleted' | 'unchanged';
  if (row._isDeleted) status = 'deleted';
  else if (row._isNew) status = 'added';
  else if (Object.keys(row._changeType).length > 0) status = 'modified';
  else status = 'unchanged';

  // 构建数据（排除内部字段，添加 tableCode）
  const data: Record<string, any> = { _tableCode: tableCode };
  for (const [key, value] of Object.entries(row)) {
    if (!key.startsWith('_')) {
      data[key] = value;
    }
  }

  // 新增行设置外键
  if (row._isNew && parentId && parentFkColumn) {
    data[parentFkColumn] = parentId;
  }

  // 构建变更记录
  const changes = Object.entries(row._changeType).map(([field, type]) => ({
    field,
    oldValue: row._originalValues[field],
    newValue: row[field],
    changeType: type
  }));

  return { id: row._isNew ? null : row.id, status, data, changes };
}
```

### 6.3 后端保存流程（DynamicDataService.java）

```java
@Transactional(rollbackFor = Exception.class)
public Long save(SaveParam param) {
    // 1. 处理主表
    switch (master.getStatus()) {
        case "added" -> {
            masterId = insert(masterTableCode, master.getData());
            auditLogService.logInsert(...);  // 审计日志
        }
        case "modified" -> {
            update(masterTableCode, masterId, master.getData());
            auditLogService.logAsync(...);   // 审计日志
        }
        case "deleted" -> {
            delete(masterTableCode, masterId);
            auditLogService.logDelete(...);  // 审计日志
        }
    }

    // 2. 执行 after_save 执行器
    if ("added".equals(status) || "modified".equals(status)) {
        actionService.execute(masterTableCode, "after_save", null, actionData, validationReport);
    }

    // 3. 处理从表（同样的流程）
    for (var entry : param.getDetails().entrySet()) {
        // 验证 → 保存 → 执行器 → 审计日志
    }

    return masterId;
}
```

### 6.4 保存后清理（store/index.ts）

```typescript
function clearChanges() {
  for (const master of masterRows.value) {
    if (master._isDeleted) continue;

    // 清除主表标记
    Object.assign(master, clearRowChanges(master));

    // 清除从表标记
    if (master._details?.rows) {
      master._details.rows = master._details.rows
        .filter(r => !r._isDeleted)  // 移除已删除行
        .map(r => clearRowChanges(r));
    }
  }

  // 移除已删除的主表行
  masterRows.value = masterRows.value.filter(r => !r._isDeleted);
}
```

---

## 七、校验规则

系统支持两层校验：前端列级校验 + 后端验证器。

### 7.1 前端列级校验（validator.ts）

**配置位置：** `T_COST_COLUMN_METADATA.RULES_CONFIG.validation`

**支持的校验类型：**

| 类型 | 配置 | 说明 |
|------|------|------|
| required | `{"required": true}` | 必填 |
| notZero | `{"notZero": true}` | 不能为零 |
| min | `{"min": 0}` | 最小值 |
| max | `{"max": 100}` | 最大值 |
| pattern | `{"pattern": "^[A-Z]+$"}` | 正则匹配 |

**配置示例：**
```json
{
  "validation": {
    "required": true,
    "notZero": true,
    "min": 0,
    "message": "价格必须大于0"
  }
}
```

**验证实现（validator.ts）：**
```typescript
function validateRow(row, rules, columns): ValidationError[] {
  const errors: ValidationError[] = [];

  for (const rule of rules) {
    const value = row[rule.field];
    const fieldLabel = columns.find(c => c.fieldName === rule.field)?.headerText || rule.field;

    // required: 必填
    if (rule.required && (value === undefined || value === null || value === '')) {
      errors.push({ field: rule.field, rowId: row.id, message: `${fieldLabel} 不能为空`, value });
      continue;
    }

    // notZero: 不能为零
    if (rule.notZero && Number(value) === 0) {
      errors.push({ field: rule.field, rowId: row.id, message: `${fieldLabel} 不能为零`, value });
    }

    // min/max/pattern...
  }

  return errors;
}
```

### 7.2 后端验证器（ValidationService.java）

**配置位置：** `T_COST_TABLE_METADATA.VALIDATION_RULES`（JSON 数组）

**字段说明：**

| 字段 | 必填 | 说明 |
|------|------|------|
| `order` | 否 | 执行顺序，默认 0 |
| `code` | 否 | 规则编码，建议唯一 |
| `name` | 否 | 规则名称 |
| `group` | 否 | 分组（如 `save`），不填表示全局规则 |
| `sql` | 是 | 验证 SQL（支持 `:param` 占位符） |
| `condition` | 是 | 条件表达式，如 `result == 0` |
| `message` | 否 | 失败提示 |

**condition 支持：** `==`、`!=`、`>`、`>=`、`<`、`<=`

**配置示例：**
```json
[
  {
    "order": 10,
    "code": "uniqueUsername",
    "group": "save",
    "sql": "SELECT COUNT(1) FROM T_COST_USER WHERE USERNAME = :username AND DELETED = 0 AND ID <> :id",
    "condition": "result == 0",
    "message": "用户名已存在"
  }
]
```

**验证实现（ValidationService.java）：**
```java
public ValidationReport validate(String tableCode, String group, Map<String, Object> data) {
    // 1. 读取验证规则
    List<ValidationRule> rules = parseRules(metadata.validationRules());
    
    // 2. 按 group 过滤
    rules = rules.stream()
        .filter(rule -> matchesGroup(rule.getGroup(), group))
        .sorted(Comparator.comparingInt(r -> r.getOrder() == null ? 0 : r.getOrder()))
        .toList();

    // 3. 逐条执行
    for (ValidationRule rule : rules) {
        String sql = SqlTemplateUtils.buildSql(rule.getSql(), data);
        Long result = dynamicMapper.selectCount(sql);
        boolean passed = evaluateCondition(result, rule.getCondition());
        
        if (!passed) {
            return ValidationReport.failed(rule.getMessage());
        }
    }

    return ValidationReport.success();
}
```

### 7.3 校验时机

| 层级 | 时机 | 说明 |
|------|------|------|
| 前端列级 | 保存前 | 校验失败阻止保存 |
| 后端验证器 | 保存时 | 自动执行 `group=save` 的规则 |

### 7.4 验证器 API

**只验证（不保存）：**
```
POST /api/data/{tableCode}/validate
{ "group": "save", "data": { "id": 1, "username": "tom" } }
```

**返回结果：**
```json
{
  "passed": true,
  "message": null,
  "results": [
    { "code": "uniqueUsername", "passed": true, "result": 0 }
  ]
}
```

---

## 八、执行器（ACTION_RULES）

执行器用于保存后自动执行或手工触发的业务逻辑。

### 8.1 配置位置

`T_COST_TABLE_METADATA.ACTION_RULES`（JSON 数组）

### 8.2 字段说明（ActionRule.java）

| 字段 | 必填 | 说明 |
|------|------|------|
| `order` | 否 | 执行顺序，默认 0 |
| `code` | 否 | 执行器编码，建议唯一 |
| `name` | 否 | 执行器名称 |
| `group` | 否 | 分组：`after_save`（保存后自动）、`manual`（手工触发） |
| `enabled` | 否 | 是否启用，默认启用 |
| `type` | 是 | 执行器类型：`sql` / `java` / `proc` |
| `sql` | 条件 | SQL 执行器必填 |
| `handler` | 条件 | Java 执行器（ActionHandler Bean 名） |
| `method` | 条件 | Java 执行器（beanName.methodName） |
| `procedure` | 条件 | 存储过程名称 |
| `params` | 否 | 存储过程参数 |
| `description` | 否 | 说明 |

### 8.3 执行器类型

**SQL 执行器（SqlActionExecutor.java）：**
```java
@Override
public ActionResult execute(ActionRule rule, ActionContext context) {
    String sql = SqlTemplateUtils.buildSql(rule.getSql(), context.getData());
    dynamicMapper.update(sql);
    return ActionResult.empty();
}
```

配置示例：
```json
{
  "code": "disableUser",
  "group": "manual",
  "type": "sql",
  "sql": "UPDATE T_COST_USER SET ENABLED = 0 WHERE ID = :id",
  "description": "禁用用户"
}
```

**Java 执行器（JavaActionExecutor.java）：**

两种方式：
1. `handler`：实现 `ActionHandler` 接口
2. `method`：指定 `beanName.methodName`

```java
@Override
public ActionResult execute(ActionRule rule, ActionContext context) {
    if (StrUtil.isBlank(rule.getHandler())) {
        return invokeMethod(rule.getMethod(), context);
    }
    ActionHandler handler = actionHandlers.get(rule.getHandler());
    return handler.execute(context);
}

private ActionResult invokeMethod(String methodRef, ActionContext context) {
    String beanName = methodRef.substring(0, methodRef.indexOf('.'));
    String methodName = methodRef.substring(methodRef.indexOf('.') + 1);
    Object bean = applicationContext.getBean(beanName);
    Method method = findMethod(bean, methodName, ActionContext.class);
    return (ActionResult) method.invoke(bean, context);
}
```

配置示例：
```json
{
  "code": "resetPassword",
  "group": "manual",
  "type": "java",
  "method": "userService.resetPassword",
  "description": "重置密码"
}
```

Java 方法签名：
```java
public ActionResult resetPassword(ActionContext context) {
    Long userId = (Long) context.getData().get("id");
    // 业务逻辑...
    return ActionResult.empty();
}
```

**存储过程执行器（ProcedureActionExecutor.java）：**

```java
@Override
public ActionResult execute(ActionRule rule, ActionContext context) {
    String callSql = buildProcedureCall(rule.getProcedure(), params.size());
    
    return jdbcTemplate.execute((Connection conn) -> {
        CallableStatement stmt = conn.prepareCall(callSql);
        int index = 1;
        for (ActionParam param : params) {
            String mode = normalizeMode(param.getMode());
            int jdbcType = resolveJdbcType(param.getJdbcType());
            
            if ("IN".equals(mode) || "INOUT".equals(mode)) {
                Object value = resolveSource(param.getSource(), context);
                stmt.setObject(index, value, jdbcType);
            }
            if ("OUT".equals(mode) || "INOUT".equals(mode)) {
                stmt.registerOutParameter(index, jdbcType);
            }
            index++;
        }
        return stmt;
    }, (CallableStatement stmt) -> {
        stmt.execute();
        ActionResult result = ActionResult.empty();
        // 读取 OUT 参数，写回 context
        int index = 1;
        for (ActionParam param : params) {
            if ("OUT".equals(mode) || "INOUT".equals(mode)) {
                Object value = stmt.getObject(index);
                applyTarget(param.getTarget(), value, context);
            }
            index++;
        }
        return result;
    });
}
```

配置示例：
```json
{
  "code": "calcCost",
  "group": "after_save",
  "type": "proc",
  "procedure": "PKG_COST.CALC_COST",
  "params": [
    { "mode": "IN", "jdbcType": "NUMBER", "source": "data.id" },
    { "mode": "OUT", "jdbcType": "NUMBER", "target": "data.totalCost" }
  ]
}
```

### 8.4 执行时机

| group | 触发方式 | 说明 |
|-------|----------|------|
| `after_save` | 自动 | 保存成功后自动执行 |
| `manual` | 手工 | 右键菜单或按钮触发 |
| 自定义 | 手工 | 如 `approve`、`cancel` |

### 8.5 执行器服务（ActionService.java）

```java
public ActionExecutionReport execute(String tableCode, String group, List<String> actionCodes, 
                                      Map<String, Object> data, ValidationReport validationReport) {
    // 1. 读取执行器规则
    List<ActionRule> rules = parseRules(metadata.actionRules());

    // 2. 过滤规则
    Set<String> codeSet = actionCodes != null ? new HashSet<>(actionCodes) : Collections.emptySet();
    boolean filterByCodes = !codeSet.isEmpty();

    rules = rules.stream()
        .filter(rule -> Boolean.FALSE != rule.getEnabled())
        .filter(rule -> filterByCodes ? matchesCode(rule, codeSet) : matchesGroup(rule.getGroup(), group))
        .sorted(Comparator.comparingInt(r -> r.getOrder() == null ? 0 : r.getOrder()))
        .toList();

    // 3. 构建上下文
    Map<String, Object> vars = new HashMap<>();
    ActionContext context = new ActionContext(tableCode, null, data, validationReport, vars);

    // 4. 逐条执行
    for (ActionRule rule : rules) {
        ActionExecutor executor = actionExecutorRegistry.getExecutor(rule.getType());
        ActionResult result = executor.execute(rule, context);
        if (result.getVars() != null) {
            vars.putAll(result.getVars());  // 合并变量
        }
        report.getExecutedActions().add(rule.getCode());
    }

    return report;
}
```

### 8.6 执行器 API

**执行指定 code：**
```
POST /api/data/{tableCode}/execute
{ "actionCodes": ["resetPassword"], "data": { "id": 1 } }
```

**执行指定分组：**
```
POST /api/data/{tableCode}/execute
{ "group": "manual", "data": { "id": 1 } }
```

**执行前先验证：**
```
POST /api/data/{tableCode}/execute
{ "group": "manual", "validate": true, "validateGroup": "save", "data": { "id": 1 } }
```

### 8.7 与右键菜单集成（MasterDetailPage.vue）

```typescript
async function handleExecuteAction(actionParams, target) {
  const { tableCode, group, actionCodes, dataFields, extraData } = actionParams;
  
  // 构建请求数据
  const data: any = { ...extraData };
  dataFields?.forEach((field: string) => {
    data[field] = target.rowData[field];
  });
  
  const { error } = await executeAction(tableCode, { group, actionCodes, data });
  if (error) {
    message.error(error.msg || '操作失败');
    return;
  }
  message.success('操作成功');
  await loadMasterData();  // 刷新数据
}
```

右键菜单配置：
```json
{
  "label": "重置密码",
  "key": "resetPwd",
  "action": "executeAction",
  "actionParams": {
    "tableCode": "CostUser",
    "group": "manual",
    "actionCodes": ["resetPassword"],
    "dataFields": ["id"]
  }
}
```

### 8.8 变量传递（ActionContext.java）

```java
@Data
@AllArgsConstructor
public class ActionContext {
    private String tableCode;
    private String actionCode;
    private Map<String, Object> data;   // 请求入参，SQL 执行器从这里取值
    private ValidationReport validation;
    private Map<String, Object> vars;   // 执行器之间的临时变量
}
```

存储过程输出值写回 `data.xxx` 后，后续 SQL 可读取：
```json
[
  {
    "order": 10,
    "code": "calcCost",
    "type": "proc",
    "params": [
      { "mode": "IN", "source": "data.id" },
      { "mode": "OUT", "target": "data.totalCost" }
    ]
  },
  {
    "order": 20,
    "code": "saveCost",
    "type": "sql",
    "sql": "UPDATE T_COST_ORDER SET TOTAL_COST = :totalCost WHERE ID = :id"
  }
]
```

---

## 九、样式规则

### 9.1 配置位置

列元数据 `T_COST_COLUMN_METADATA.RULES_CONFIG.style`

### 9.2 支持的条件类型（useMetaColumns.ts）

| 类型 | 说明 | 配置示例 |
|------|------|----------|
| contains | 包含 | `{"type": "contains", "pattern": "亏"}` |
| startsWith | 开头 | `{"type": "startsWith", "pattern": "A"}` |
| endsWith | 结尾 | `{"type": "endsWith", "pattern": "元"}` |
| equals | 等于 | `{"type": "equals", "compareValue": "停产"}` |
| compare | 比较 | `{"type": "compare", "operator": ">", "compareValue": 100}` |

### 9.3 配置示例

```json
{
  "style": [
    {
      "condition": {"type": "contains", "pattern": "亏"},
      "cellStyle": {"color": "red", "fontWeight": "bold"}
    },
    {
      "condition": {"type": "contains", "pattern": "停"},
      "rowStyle": {"backgroundColor": "#e3f2fd"}
    }
  ]
}
```

### 9.4 实现机制（useMetaColumns.ts）

```typescript
// 1. 解析 rulesConfig.style 生成 cellClassRules
if (config.style && Array.isArray(config.style)) {
  const cellClassRules: Record<string, (params: any) => boolean> = {};
  
  config.style.forEach((rule: StyleRule, index: number) => {
    const className = `meta-cell-${col.fieldName}-${index}`;
    
    cellClassRules[className] = (params: any) => {
      const value = params.value;
      if (value == null) return false;
      return matchStyleRule(value, rule.condition);
    };
  });
  
  colDef.cellClassRules = cellClassRules;
}

// 2. 动态注入 CSS 样式到页面
function injectDynamicStyles(columns, rowStyleRules) {
  const styleEl = document.getElementById('meta-dynamic-styles') || document.createElement('style');
  // 生成 CSS 规则并注入
}
```

### 9.5 行样式规则

行样式需要更具体的选择器覆盖 AG Grid 默认样式：

```typescript
// 使用更具体的选择器确保覆盖
newRules.push(`.ag-row.${rule.className} { ${styleStr} !important; }`);
newRules.push(`.ag-row.${rule.className} .ag-cell { ${styleStr} !important; }`);
```

---

## 十、Lookup 弹窗选择器

### 10.1 配置位置

列元数据 `T_COST_COLUMN_METADATA.RULES_CONFIG.lookup`

### 10.2 配置示例

```json
{
  "lookup": {
    "code": "material",
    "mapping": {
      "apexGoodsname": "materialName",
      "price": "price"
    }
  }
}
```

| 字段 | 说明 |
|------|------|
| code | Lookup 配置编码（关联 T_COST_LOOKUP_CONFIG） |
| mapping | 回填映射：目标字段 → 源字段 |

### 10.3 交互流程（LookupDialog.vue）

```typescript
// 1. 用户点击配置了 Lookup 的单元格
function onDetailCellClicked(event) {
  const rule = detailLookupRules.value.find(r => r.fieldName === event.field);
  if (!rule) return;
  
  currentLookupRule.value = rule;
  currentLookupRowId.value = event.rowId;
  lookupDialogRef.value?.open();
}

// 2. 打开 LookupDialog，加载数据
async function open() {
  visible.value = true;
  if (!config.value) {
    const { data } = await fetchLookupConfig(props.lookupCode);
    config.value = data;
  }
  await loadData();
}

// 3. 用户选择一行，点击确定
function handleConfirm() {
  const fillData: Record<string, any> = {};
  for (const [targetField, sourceField] of Object.entries(props.mapping)) {
    fillData[targetField] = selectedRow.value[sourceField];
  }
  emit('select', fillData);
}

// 4. 根据 mapping 回填多个字段，触发计算
function onLookupSelect(fillData: Record<string, any>) {
  store.updateFields(currentLookupRowId.value, fillData, currentLookupIsMaster.value);
}
```

### 10.4 批量更新触发计算（store/index.ts）

```typescript
function updateFields(rowId: number, updates: Record<string, any>, isMaster = false) {
  const changedFields: string[] = [];
  for (const [field, value] of Object.entries(updates)) {
    if (updateFieldSilent(rowId, field, value, isMaster)) {
      changedFields.push(field);
    }
  }

  if (changedFields.length === 0) return;
  triggerRowCalc(rowId, changedFields, isMaster);  // 触发完整计算链
}
```

---

## 十一、右键菜单

### 11.1 配置位置

页面组件 `T_COST_PAGE_COMPONENT`，`COMPONENT_TYPE = 'CONTEXT_MENU'`

### 11.2 配置示例

```json
{
  "items": [
    {
      "label": "新增行",
      "key": "add",
      "icon": "mdi:plus",
      "action": "addRow"
    },
    {
      "label": "复制行",
      "key": "copy",
      "icon": "mdi:content-copy",
      "action": "copyRow",
      "disabled": "!selectedRow"
    },
    {"type": "divider"},
    {
      "label": "删除行",
      "key": "delete",
      "icon": "mdi:delete",
      "action": "deleteRow",
      "confirm": true,
      "confirmMessage": "确认删除该行吗？"
    },
    {
      "label": "重置密码",
      "key": "resetPwd",
      "action": "executeAction",
      "actionParams": {
        "tableCode": "CostUser",
        "group": "manual",
        "actionCodes": ["resetPassword"],
        "dataFields": ["id"]
      }
    }
  ]
}
```

### 11.3 支持的 action（MasterDetailPage.vue）

| action | 说明 |
|--------|------|
| addRow | 新增行 |
| copyRow | 复制行（含从表数据） |
| deleteRow | 删除行（软删除） |
| editRow | 编辑行 |
| refresh | 刷新数据 |
| executeAction | 执行后端执行器 |

### 11.4 复制行实现（含从表数据）

```typescript
if (key === 'copy' && target.rowData) {
  const sourceData = { ...target.rowData };
  delete sourceData.id;
  // 删除内部字段...
  
  if (target.isMaster) {
    const sourceDetails = sourceData._details;
    delete sourceData._details;
    
    const newRow = store.addMasterRow(sourceData);
    
    // 复制从表数据
    if (sourceDetails?.rows?.length > 0) {
      for (const detailRow of sourceDetails.rows) {
        if (detailRow._isDeleted) continue;
        
        const detailCopy = { ...detailRow };
        delete detailCopy.id;
        // 设置新的外键关联
        if (fkField) detailCopy[fkField] = newRow.id;
        
        newRow._details!.rows.push({
          ...detailCopy,
          id: generateTempId(),
          _isNew: true,
          _changeType: {},
          _originalValues: {}
        });
      }
    }
  }
}
```

---

## 十二、Tab 分组显示

### 12.1 分组模式（mode: group）

同一张从表，按字段值分组显示在不同 Tab：

```json
{
  "mode": "group",
  "groupField": "dtlUseflag",
  "tabs": [
    {"key": "ylfl", "title": "原料/辅料", "values": ["原料", "辅料"]},
    {"key": "bc", "title": "包材", "values": ["印字包材", "非印字包材"]}
  ]
}
```

**数据过滤逻辑（store/index.ts）：**
```typescript
const detailRowsByTab = computed(() => {
  const result: Record<string, RowData[]> = {};
  const tabs = config.value?.tabs || [];
  const groupField = config.value?.groupField;

  for (const tab of tabs) {
    if (tab.mode === 'group') {
      // groupValues 优先（多个分组值合并到一个 Tab）
      if (tab.groupValues && tab.groupValues.length > 0 && groupField) {
        result[tab.key] = visibleDetailRows.value.filter(
          r => tab.groupValues!.includes(r[groupField] as string)
        );
      }
      // groupValue 为 * 或未设置时，显示所有数据
      else if (!tab.groupValue || tab.groupValue === '*' || !groupField) {
        result[tab.key] = visibleDetailRows.value;
      } else {
        result[tab.key] = visibleDetailRows.value.filter(
          r => r[groupField] === tab.groupValue
        );
      }
    }
  }
  return result;
});
```

### 12.2 Tab 初始排序（MetaTabs.vue）

```typescript
function onGridReady(tabKey: string, params: GridReadyEvent) {
  gridApis.set(tabKey, params.api);
  
  // 应用初始排序
  const tab = props.tabs.find(t => t.key === tabKey);
  if (tab?.initialSort && tab.initialSort.length > 0) {
    params.api.applyColumnState({
      state: tab.initialSort,
      defaultState: { sort: null }
    });
  }
}
```

配置示例：
```json
{
  "initialSort": [
    {"colId": "dtlUseflag", "sort": "asc"}
  ]
}
```

---

## 十三、企业版功能

### 13.1 侧边栏（Side Bar）

```typescript
const sideBar = {
  toolPanels: [
    {
      id: 'columns',
      toolPanel: 'agColumnsToolPanel',
      toolPanelParams: {
        suppressRowGroups: true,
        suppressValues: true,
        suppressPivots: true,
        suppressPivotMode: true
      }
    },
    {
      id: 'filters',
      toolPanel: 'agFiltersToolPanel'
    }
  ],
  position: 'right'
};
```

### 13.2 自定义排序（useMetaColumns.ts）

列元数据配置：
```json
{
  "comparator": "customCategorySort"
}
```

实现：
```typescript
function getComparator(comparatorName: string) {
  const comparators = {
    customCategorySort: (valueA, valueB) => {
      const order = { '原料': 1, '辅料': 2, '印字包材': 3, '非印字包材': 4 };
      return (order[valueA] || 999) - (order[valueB] || 999);
    }
  };
  return comparators[comparatorName];
}
```

### 13.3 历史数据对比（DynamicDataService.java）

```java
private void mergeHistoryData(List<Map<String, Object>> list, TableMetadataDTO metadata, ...) {
    // 1. 找出配置了 compare.enabled=true 的列
    List<CompareColumn> compareColumns = findCompareColumns(metadata);
    
    // 2. 查询历史表（表名_HIS）中昨天的数据
    String historySql = String.format(
        "SELECT ID, %s FROM %s WHERE ID IN (%s) AND TRUNC(HIS_TIME) = TRUNC(SYSDATE - 1)",
        columnList, historyTable, idList
    );
    
    // 3. 合并到主数据，添加 xxxHis、xxxDiff、xxxDiffPercent 字段
    for (Map<String, Object> row : list) {
        for (CompareColumn col : compareColumns) {
            row.put(col.fieldName + "His", historyValue);
            row.put(col.fieldName + "Diff", current - history);
            row.put(col.fieldName + "DiffPercent", (diff / history) * 100);
        }
    }
}
```

配置示例：
```json
{
  "compare": {
    "enabled": true,
    "format": "both"
  }
}
```

---

## 十四、变更状态样式

### 14.1 单元格样式（useGridAdapter.ts）

| 样式类 | 背景色 | 说明 |
|--------|--------|------|
| cell-user-changed | #e6ffe6（浅绿） | 用户编辑的字段 |
| cell-cascade-changed | #fffde6（浅黄） | 公式计算的字段 |
| cell-new-row | #f0f9ff（浅蓝） | 新增行 |

### 14.2 实现机制

```typescript
export function getCellClassRules() {
  return {
    'cell-user-changed': (params) => params.data?._changeType?.[params.colDef.field] === 'user',
    'cell-cascade-changed': (params) => params.data?._changeType?.[params.colDef.field] === 'cascade',
    'cell-new-row': (params) => params.data?._isNew === true
  };
}

export const cellStyleCSS = `
.cell-user-changed { background-color: #e6ffe6 !important; }
.cell-cascade-changed { background-color: #fffde6 !important; }
.cell-new-row { background-color: #f0f9ff !important; }
`;
```

---

## 十五、快捷键支持

### 15.1 Ctrl+S 保存（MasterDetailPage.vue）

```typescript
function onKeyDown(e: KeyboardEvent) {
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    handleSave();
  }
}

onMounted(() => {
  document.addEventListener('keydown', onKeyDown);
});

onUnmounted(() => {
  document.removeEventListener('keydown', onKeyDown);
});
```

### 15.2 离开页面提示

```typescript
function onBeforeUnload(e: BeforeUnloadEvent) {
  if (store.isDirty) {
    e.preventDefault();
    e.returnValue = '';
  }
}

onMounted(() => {
  window.addEventListener('beforeunload', onBeforeUnload);
});
```

---

## 十六、关键设计决策总结

| 设计点 | 决策 | 原因 |
|--------|------|------|
| 从表数据挂在主表行下 | 嵌套结构 `_details` | 切换主表行时数据不丢失 |
| 加载数据不触发计算 | 只刷新 UI | 后端数据已是计算结果 |
| 编辑时增量计算 | 只算受影响规则 | 性能优化 |
| LRU 缓存 | 最多 50 个 | 限制内存占用 |
| 有修改的数据不清理 | 保护用户数据 | 避免丢失未保存的修改 |
| 变更追踪区分 user/cascade | 不同颜色标识 | 用户可区分手动修改和自动计算 |
| 临时 ID 用负数 | 避免与数据库 ID 冲突 | 新增行在保存前需要唯一标识 |
| 多公式模式 | 根据字段值选公式 | 同一列不同行使用不同计算逻辑 |
| 聚合后处理 | JS 表达式修正 | 支持复杂的聚合结果调整 |

---

## 十七、待改进项

1. **多表模式（mode: multi）**：当前未完全实现
2. **变体列支持**：同一从表不同分组显示不同列
3. **三层嵌套 Master-Detail**：AG Grid 原生支持，当前未使用
4. **离线编辑**：当前依赖网络，无离线支持
5. **撤销/重做**：当前无历史记录功能

---

*文档版本：v2.0*
*更新日期：2026-01-10*
