# V3 客户端查询改造方案（一次加载 + 前端筛选）

## 目标
- 主表与明细全部切换为 Client-Side Row Model。
- 页面初始化一次性拉取全部数据（不再分块/滚动请求）。
- 排序/筛选/分页全部由前端处理，后端只提供全量数据。

## 现状问题
- 当前 V3 强制 SSRM，排序/筛选触发频繁重置数据源，导致循环请求。
- SSRM 逻辑较复杂（refreshServerSide / datasource / 缓存），维护成本高。

## 改造范围（核心改动点）
### 1) 元数据与配置层
涉及文件：
- `cost-web/src/v3/composables/meta-v3/useMetaConfig.ts`

要点：
- 取消“主表强制 serverSide”的逻辑。
- 默认 `rowModelType = 'clientSide'`。
- 去掉 SSRM 默认参数（cacheBlockSize / maxConcurrentDatasourceRequests / blockLoadDebounceMillis）。
- 明细表仍保持 clientSide（保持不变）。

### 2) 数据加载与缓存
涉及文件：
- `cost-web/src/v3/composables/meta-v3/useMasterDetailData.ts`
- `cost-web/src/service/api/dynamic.ts`

要点：
- 恢复/实现 `loadMasterData`，一次性拉取全量数据：
  - 调用 `searchDynamicData`，设置 `pageSize <= 0`（后端支持不分页）。
  - 或直接调用 `/api/data/{tableCode}/all`（已有后端接口）。
- 恢复 `masterRows` 本地数组，并由它驱动 grid `rowData`。
- 移除 `createServerSideDataSource` 及 SSRM 分支逻辑。
- `add/delete/copy` 使用 `applyTransaction`（clientSide）。

### 3) Runtime 与 Grid 绑定
涉及文件：
- `cost-web/src/v3/composables/meta-v3/runtime/index.ts`
- `cost-web/src/v3/composables/meta-v3/useMasterGridBindings.ts`
- `cost-web/src/v3/components/meta-v3/renderers/MetaGridV3.vue`

要点：
- `GridState.rowData` 改为 `masterRows`。
- `applyExtensions` 不再设置 `serverSideDatasource`。
- `executeAction` 中去掉 refreshServerSide；改为 `loadMasterData()` 或单行刷新逻辑。
- 删除 `onFilterChanged/onSortChanged` 的 SSRM 刷新逻辑，完全依赖前端过滤排序。
- `MetaGridV3` 移除 datasource 分支，`rowData` 直接使用 state.rowData。

### 4) 保存逻辑
涉及文件：
- `cost-web/src/v3/composables/meta-v3/useSave.ts`

要点：
- 保存时主表脏数据改为从 `masterRows` 收集。
- 主表更新/删除使用 `applyTransaction`。
- 删除 SSRM 专用逻辑。

## 后端支持（已满足）
已存在能力：
- `/api/data/{tableCode}/search` 支持 `pageSize<=0` 不分页。
- `/api/data/{tableCode}/all` 可直接返回全量数据。
无需新增后端接口。

## 风险与对策
- 数据量过大导致前端卡顿：
  - 可设定阈值（如 >5000 提示），或增加分页/SSR M 作为可选开关。
  - 若需要保留回退，可在元数据增加开关字段。

## 回归验证清单
- 页面初始化：一次请求即返回全部数据。
- 排序/筛选：前端立即生效，无网络请求。
- 新增/删除/复制：前端 rowData 正常变化。
- 明细加载/广播/汇总：逻辑不受影响。
- 保存后：主表与明细状态清理正常。

## 回退方案
- 保留 SSRM 逻辑分支（可配置开关），必要时快速切回。

